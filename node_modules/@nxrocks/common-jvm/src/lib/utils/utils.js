"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAdjustedProjectAndModuleRoot = exports.getPathToParentModule = exports.getPathFromParentModule = exports.checkProjectFileContains = exports.checkProjectBuildFileContains = exports.getJvmPackageInfo = exports.getGradleDependencyIdRegEx = exports.getGradleBuildFilesExtensionInTree = exports.getGradleBuildFilesExtension = exports.hasGradleBuildFile = exports.hasGradleSettingsFile = exports.hasGradleProject = exports.isGradleProjectSettingsInTree = exports.isGradleProjectInTree = exports.isGradleProject = exports.hasMavenProject = exports.isMavenProjectInTree = exports.isMavenProject = exports.runBuilderCommand = exports.JVM_PROJECT_FILES = exports.LARGE_BUFFER = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const child_process_1 = require("child_process");
const fileutils_1 = require("@nx/workspace/src/utilities/fileutils");
const common_1 = require("@nxrocks/common");
const utils_1 = require("../utils");
const maven_utils_1 = require("./maven-utils");
const gradle_utils_1 = require("./gradle-utils");
const path_1 = require("path");
exports.LARGE_BUFFER = 1024 * 1000000;
exports.JVM_PROJECT_FILES = [
    'pom.xml',
    'build.gradle',
    'build.gradle.kts',
    'settings.gradle',
    'settings.gradle.kts',
];
function runBuilderCommand(commandAlias, getBuilder, params, options = {
    cwd: process.cwd(),
    ignoreWrapper: false,
    useLegacyWrapper: false,
    runFromParentModule: false,
}) {
    var _a, _b;
    // Take the parameters or set defaults
    const buildSystem = getBuilder(options.cwd);
    const executable = buildSystem.getExecutable((_a = options.ignoreWrapper) !== null && _a !== void 0 ? _a : false, (_b = options.useLegacyWrapper) !== null && _b !== void 0 ? _b : false);
    const { cwd, command } = buildSystem.getCommand(commandAlias, options);
    // Create the command to execute
    const execute = `${executable} ${command} ${(params || []).join(' ')}`;
    try {
        devkit_1.logger.info(`Executing command: ${execute}`);
        (0, child_process_1.execSync)(execute, { cwd, stdio: [0, 1, 2], maxBuffer: exports.LARGE_BUFFER });
        return { success: true };
    }
    catch (e) {
        devkit_1.logger.error(`Failed to execute command: ${execute}`);
        devkit_1.logger.error(e);
        return { success: false };
    }
}
exports.runBuilderCommand = runBuilderCommand;
function isMavenProject(project) {
    return (0, fileutils_1.fileExists)((0, common_1.getProjectFilePath)(project, 'pom.xml'));
}
exports.isMavenProject = isMavenProject;
function isMavenProjectInTree(tree, rootFolder) {
    return tree.exists(`./${rootFolder}/pom.xml`);
}
exports.isMavenProjectInTree = isMavenProjectInTree;
function hasMavenProject(cwd) {
    return (0, fileutils_1.fileExists)(`${cwd}/pom.xml`);
}
exports.hasMavenProject = hasMavenProject;
function isGradleProject(project) {
    return ((0, fileutils_1.fileExists)((0, common_1.getProjectFilePath)(project, 'build.gradle')) ||
        (0, fileutils_1.fileExists)((0, common_1.getProjectFilePath)(project, 'settings.gradle')) ||
        (0, fileutils_1.fileExists)((0, common_1.getProjectFilePath)(project, 'build.gradle.kts')) ||
        (0, fileutils_1.fileExists)((0, common_1.getProjectFilePath)(project, 'settings.gradle.kts')));
}
exports.isGradleProject = isGradleProject;
function isGradleProjectInTree(tree, rootFolder) {
    return (tree.exists(`./${rootFolder}/build.gradle`) ||
        tree.exists(`./${rootFolder}/settings.gradle`) ||
        tree.exists(`./${rootFolder}/build.gradle.kts`) ||
        tree.exists(`./${rootFolder}/settings.gradle.kts`));
}
exports.isGradleProjectInTree = isGradleProjectInTree;
function isGradleProjectSettingsInTree(tree, rootFolder) {
    return (tree.exists(`./${rootFolder}/settings.gradle`) ||
        tree.exists(`./${rootFolder}/settings.gradle.kts`));
}
exports.isGradleProjectSettingsInTree = isGradleProjectSettingsInTree;
function hasGradleProject(cwd) {
    return ((0, fileutils_1.fileExists)(`${cwd}/build.gradle`) ||
        (0, fileutils_1.fileExists)(`${cwd}/settings.gradle`) ||
        (0, fileutils_1.fileExists)(`${cwd}/build.gradle.kts`) ||
        (0, fileutils_1.fileExists)(`${cwd}/settings.gradle.kts`));
}
exports.hasGradleProject = hasGradleProject;
function hasGradleSettingsFile(cwd) {
    return ((0, fileutils_1.fileExists)(`${cwd}/settings.gradle`) ||
        (0, fileutils_1.fileExists)(`${cwd}/settings.gradle.kts`));
}
exports.hasGradleSettingsFile = hasGradleSettingsFile;
function hasGradleBuildFile(cwd) {
    return ((0, fileutils_1.fileExists)(`${cwd}/build.gradle`) || (0, fileutils_1.fileExists)(`${cwd}/build.gradle.kts`));
}
exports.hasGradleBuildFile = hasGradleBuildFile;
function getGradleBuildFilesExtension(project) {
    if ((0, fileutils_1.fileExists)((0, common_1.getProjectFilePath)(project, 'build.gradle.kts')) ||
        (0, fileutils_1.fileExists)((0, common_1.getProjectFilePath)(project, 'settings.gradle.kts'))) {
        return '.gradle.kts';
    }
    return (0, fileutils_1.fileExists)((0, common_1.getProjectFilePath)(project, 'build.gradle')) ||
        (0, fileutils_1.fileExists)((0, common_1.getProjectFilePath)(project, 'settings.gradle'))
        ? '.gradle'
        : undefined;
}
exports.getGradleBuildFilesExtension = getGradleBuildFilesExtension;
function getGradleBuildFilesExtensionInTree(tree, rootFolder) {
    if (tree.exists(`./${rootFolder}/build.gradle.kts`) ||
        tree.exists(`./${rootFolder}/settings.gradle.kts`)) {
        return '.gradle.kts';
    }
    return tree.exists(`./${rootFolder}/build.gradle`) ||
        tree.exists(`./${rootFolder}/settings.gradle`)
        ? '.gradle'
        : undefined;
}
exports.getGradleBuildFilesExtensionInTree = getGradleBuildFilesExtensionInTree;
const getGradleDependencyIdRegEx = () => /\s*(api|implementation|testImplementation)\s*(\(?project)?\s*\(?['"](?<id>[^"']+)['"]\)?\)?/g;
exports.getGradleDependencyIdRegEx = getGradleDependencyIdRegEx;
function getJvmPackageInfo(project) {
    var _a;
    if (isMavenProject(project)) {
        // maven project
        const pomXmlStr = (0, common_1.getProjectFileContent)(project, 'pom.xml');
        const pomXmlNode = (0, utils_1.readXml)(pomXmlStr);
        const { groupId, artifactId } = (0, maven_utils_1.getCoordinatesForMavenProjet)(project.root);
        const dependencies = [];
        const dependencyNodes = (0, utils_1.findXmlNodes)(pomXmlNode, `/project/dependencies/dependency`);
        if (Array.isArray(dependencyNodes)) {
            dependencyNodes === null || dependencyNodes === void 0 ? void 0 : dependencyNodes.forEach((node) => {
                const depGroupId = (0, utils_1.findNodeContent)(node, `/dependency/groupId/text()`);
                const depArtifactId = (0, utils_1.findNodeContent)(node, `/dependency/artifactId/text()`);
                dependencies.push({
                    packageId: `${depGroupId}:${depArtifactId}`,
                    packageFile: 'pom.xml',
                });
            });
        }
        const modules = (0, maven_utils_1.getMavenModules)(project.root);
        return {
            packageId: `${groupId}:${artifactId}`,
            packageFile: 'pom.xml',
            dependencies,
            modules: modules.map((mod) => `${groupId}:${mod}`),
        };
    }
    if (isGradleProject(project)) {
        // gradle project
        const ext = getGradleBuildFilesExtension(project);
        const { groupId, artifactId } = (0, gradle_utils_1.getCoordinatesForGradleProjet)(project.root);
        const gradleDependencyIdRegEx = (0, exports.getGradleDependencyIdRegEx)();
        const dependencyIds = [];
        if (hasGradleBuildFile(project.root)) {
            const buildGradle = (0, common_1.getProjectFileContent)(project, `build${ext}`);
            let match;
            do {
                match = gradleDependencyIdRegEx.exec(buildGradle);
                const id = (_a = match === null || match === void 0 ? void 0 : match.groups) === null || _a === void 0 ? void 0 : _a['id'];
                if (id) {
                    // project dependencies start with ':', we prepend the groupId to it
                    dependencyIds.push(id.startsWith(':') ? `${groupId}${id}` : id);
                }
            } while (match);
        }
        const dependencies = dependencyIds.map((depId) => {
            return { packageId: depId, packageFile: `build${ext}` };
        });
        const modules = (0, gradle_utils_1.getGradleModules)(project.root);
        const offsetFromRoot = getPathFromParentModule(project.root);
        const pkgId = offsetFromRoot
            ? offsetFromRoot.replaceAll('/', ':')
            : artifactId;
        return {
            packageId: `${groupId}:${pkgId}`,
            packageFile: hasGradleSettingsFile(project.root)
                ? `settings${ext}`
                : `build${ext}`,
            dependencies,
            modules: modules.map((mod) => `${groupId}:${mod}`),
        };
    }
    throw new Error(`Cannot inspect dependencies of project at: '${(0, common_1.getProjectRoot)(project)}'.\n` + `No 'pom.xml' nor 'build.gradle[.kts]' was found.`);
}
exports.getJvmPackageInfo = getJvmPackageInfo;
function checkProjectBuildFileContains(project, opts, searchInParentModule = true) {
    let found = false;
    if (isMavenProject(project) && (0, common_1.hasProjectFile)(project, 'pom.xml')) {
        const content = (0, common_1.getProjectFileContent)(project, 'pom.xml');
        found = checkProjectFileContains(content, opts);
        if (!found && searchInParentModule) {
            //not found in the project, check at parent module level
            const parentRoot = getPathToParentModule(project.root);
            if ((0, common_1.hasProjectFile)({ root: parentRoot }, 'pom.xml')) {
                const parentModuleContent = (0, common_1.getProjectFileContent)({ root: parentRoot }, 'pom.xml');
                return checkProjectFileContains(parentModuleContent, opts);
            }
        }
    }
    const ext = getGradleBuildFilesExtension(project);
    if (isGradleProject(project) &&
        ext &&
        (0, common_1.hasProjectFile)(project, `build${ext}`)) {
        const content = (0, common_1.getProjectFileContent)(project, `build${ext}`);
        found = checkProjectFileContains(content, opts);
        if (!found && searchInParentModule) {
            //not found in the project, check at parent module level
            const parentRoot = getPathToParentModule(project.root);
            if ((0, common_1.hasProjectFile)({ root: parentRoot }, `build${ext}`)) {
                const parentModuleContent = (0, common_1.getProjectFileContent)({ root: parentRoot }, `build${ext}`);
                return checkProjectFileContains(parentModuleContent, opts);
            }
        }
    }
    return found;
}
exports.checkProjectBuildFileContains = checkProjectBuildFileContains;
function checkProjectFileContains(content, opts) {
    const { fragments, logicalOp = (fragments === null || fragments === void 0 ? void 0 : fragments.length) === 1 ? 'and' : 'or' } = opts;
    const findOccurencesInContent = (content) => {
        return (fragments || []).reduce((acc, curr) => {
            return logicalOp === 'and'
                ? acc && match(content, curr)
                : acc || match(content, curr);
        }, logicalOp === 'and');
    };
    return findOccurencesInContent(content);
}
exports.checkProjectFileContains = checkProjectFileContains;
function getPathFromParentModule(cwd) {
    let pathFromParent = [];
    let root, name;
    let currentFolder = cwd;
    do {
        const obj = (0, common_1.getNameAndRoot)(currentFolder);
        root = obj.root;
        name = obj.name;
        currentFolder = root;
        if (root !== '.') {
            pathFromParent = [name, ...pathFromParent];
        }
    } while (!(hasGradleBuildFile(root) && (0, gradle_utils_1.hasGradleModule)(root, name)) &&
        !(hasMavenProject(root) && (0, maven_utils_1.hasMavenModule)(root, name)) &&
        root !== '.');
    return pathFromParent.slice(1).join('/');
}
exports.getPathFromParentModule = getPathFromParentModule;
function getPathToParentModule(cwd) {
    let root, name;
    let currentFolder = cwd;
    do {
        const obj = (0, common_1.getNameAndRoot)(currentFolder);
        root = obj.root;
        name = obj.name;
        currentFolder = root;
    } while (!(hasGradleBuildFile(root) && (0, gradle_utils_1.hasGradleModule)(root, name)) &&
        !(hasMavenProject(root) && (0, maven_utils_1.hasMavenModule)(root, name)) &&
        root !== '.');
    return root;
}
exports.getPathToParentModule = getPathToParentModule;
function getAdjustedProjectAndModuleRoot(options, isMavenProject) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const projectGraph = process.env['NX_INTERACTIVE'] === 'true'
            ? (0, devkit_1.readCachedProjectGraph)()
            : yield (0, devkit_1.createProjectGraphAsync)();
        if (options.addToExistingParentModule &&
            options.parentModuleName &&
            !projectGraph.nodes[options.parentModuleName]) {
            throw new Error(`No parent module project named '${options.parentModuleName}' was found in this workspace! Make sure the project exists.`);
        }
        const indexOfPathSlash = isMavenProject
            ? options.projectRoot.lastIndexOf('/')
            : options.projectRoot.indexOf('/');
        let projectRoot = options.projectRoot;
        let moduleRoot;
        if (options.addToExistingParentModule && options.parentModuleName) {
            moduleRoot = projectGraph.nodes[options.parentModuleName].data.root;
        }
        else {
            const rootFolder = options.projectRoot.substring(0, indexOfPathSlash);
            moduleRoot = `${rootFolder}/${options.parentModuleName}`;
        }
        projectRoot = `${moduleRoot}/${options.projectRoot.substring(indexOfPathSlash + 1)}`;
        const offsetFromRoot = (0, path_1.dirname)((0, path_1.relative)(moduleRoot, projectRoot));
        return {
            projectRoot,
            moduleRoot,
            offsetFromRoot,
        };
    });
}
exports.getAdjustedProjectAndModuleRoot = getAdjustedProjectAndModuleRoot;
function match(content, value) {
    if (typeof value === 'string') {
        return content.includes(value);
    }
    else {
        return value.test(content);
    }
}
//# sourceMappingURL=utils.js.map