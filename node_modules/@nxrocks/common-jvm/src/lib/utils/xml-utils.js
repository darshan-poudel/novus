"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isXmlNodeEmpty = exports.addXmlElement = exports.removeXmlNode = exports.addXmlNode = exports.newXmlNode = exports.findXmlMatching = exports.hasXmlMatching = exports.findXmlContents = exports.findXmlContent = exports.findNodeContent = exports.findXmlNode = exports.findXmlNodes = exports.readXml = void 0;
const xmlbuilder2_1 = require("xmlbuilder2");
const xpath_1 = require("xpath");
function readXml(xmlContent, ignoreNamespace = true) {
    if (!xmlContent) {
        throw new Error('Cannot read XML, provided content is empty');
    }
    return (0, xmlbuilder2_1.create)(ignoreNamespace
        ? {
            defaultNamespace: {
                ele: null,
                att: null,
            },
        }
        : {}, xmlContent);
}
exports.readXml = readXml;
function findXmlNodes(xml, xpath, ignoreNamespace = true) {
    let realXpath = xpath;
    if (ignoreNamespace) {
        const prefix = xpath.startsWith('//') ? '//' : '/';
        realXpath =
            prefix +
                xpath
                    .split('/')
                    .filter((p) => p.length > 0)
                    .map((p) => p.trim() === '..'
                    ? p
                    : p
                        .trim()
                        .replace(/^([\w-.:]+)(?:\[[^]+\])?$/, `*[local-name(.) = '$1']`))
                    .join('/');
    }
    return (0, xpath_1.select)(realXpath, asXmlNode(xml));
}
exports.findXmlNodes = findXmlNodes;
function findXmlNode(xml, xpath, ignoreNamespace = true) {
    const nodes = findXmlNodes(xml, xpath, ignoreNamespace);
    return Array.isArray(nodes) ? nodes[0] : undefined;
}
exports.findXmlNode = findXmlNode;
function findNodeContent(source, xpath, ignoreNamespace = true) {
    return findXmlContent(asNewXMLBuilder(source), xpath, ignoreNamespace);
}
exports.findNodeContent = findNodeContent;
function findXmlContent(xml, xpath, ignoreNamespace = true) {
    const node = findXmlNode(xml, xpath, ignoreNamespace);
    if (isNode(node)) {
        return node.textContent;
    }
    return node === null || node === void 0 ? void 0 : node.toString();
}
exports.findXmlContent = findXmlContent;
function findXmlContents(xml, xpath, ignoreNamespace = true) {
    const nodes = findXmlNodes(xml, xpath, ignoreNamespace);
    if (Array.isArray(nodes)) {
        return nodes.map(n => n.textContent).filter(v => v !== null);
    }
    return [];
}
exports.findXmlContents = findXmlContents;
function hasXmlMatching(xml, xpath, ignoreNamespace = true) {
    const result = findXmlNodes(xml, xpath, ignoreNamespace);
    if (Array.isArray(result))
        return (result === null || result === void 0 ? void 0 : result.length) > 0;
    return !!result;
}
exports.hasXmlMatching = hasXmlMatching;
function findXmlMatching(xml, xpath, ignoreNamespace = true) {
    const value = findXmlNode(xml, xpath, ignoreNamespace);
    if (value) {
        return asXMLBuilder(value, ignoreNamespace);
    }
    return null;
}
exports.findXmlMatching = findXmlMatching;
function newXmlNode(content) {
    return (0, xmlbuilder2_1.create)(content);
}
exports.newXmlNode = newXmlNode;
function addXmlNode(target, node) {
    const child = newXmlNode(node);
    return target.import(child);
}
exports.addXmlNode = addXmlNode;
function removeXmlNode(nodeToRemove) {
    return nodeToRemove.remove();
}
exports.removeXmlNode = removeXmlNode;
function addXmlElement(target, ...elements) {
    let result = target;
    elements.forEach((elm) => {
        result =
            typeof elm === 'string'
                ? result.ele(elm)
                : result.ele(elm.name, elm.attributes);
    });
    return result;
}
exports.addXmlElement = addXmlElement;
function isXmlNodeEmpty(xml) {
    try {
        return !xml.first();
    }
    catch (error) {
        return true;
    }
}
exports.isXmlNodeEmpty = isXmlNodeEmpty;
function asNewXMLBuilder(node, ignoreNamespace = true) {
    return readXml((0, xmlbuilder2_1.builder)(node).toString(), ignoreNamespace);
}
function asXMLBuilder(node, ignoreNamespace = true) {
    return (0, xmlbuilder2_1.builder)(ignoreNamespace
        ? {
            defaultNamespace: {
                ele: null,
                att: null,
            },
        }
        : {}, node);
}
function asXmlNode(xml) {
    return xml.node;
}
function isNode(value) {
    return (value === null || value === void 0 ? void 0 : value.nodeType) !== undefined;
}
//# sourceMappingURL=xml-utils.js.map