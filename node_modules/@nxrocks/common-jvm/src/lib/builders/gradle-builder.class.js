"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GradleBuilder = void 0;
const constants_1 = require("../constants");
const builder_core_interface_1 = require("./builder-core.interface");
const utils_1 = require("../utils");
const path_1 = require("path");
class GradleBuilder {
    constructor(commandAliases) {
        this.commandAliases = commandAliases;
    }
    getBuildSystemType() {
        return builder_core_interface_1.BuildSystem.GRADLE;
    }
    getExecutable(ignoreWrapper, useLegacyWrapper = false) {
        return ignoreWrapper ? constants_1.GRADLE_EXECUTABLE : constants_1.GRADLE_WRAPPER_EXECUTABLE;
    }
    getCommand(alias, options) {
        let additionalArgs = '';
        let cwd = options.cwd;
        if (!options.ignoreWrapper && !(0, utils_1.hasGradleWrapper)(options.cwd) && !options.runFromParentModule) {
            throw new Error(`⚠️ You chose not to use the Gradle wrapper from the parent module, but no wrapper was found in current child module`);
        }
        if (options.runFromParentModule) {
            let pathToModule = [];
            const childModuleName = (0, path_1.basename)(cwd);
            do {
                const module = (0, path_1.basename)(cwd);
                cwd = (0, path_1.resolve)(cwd, '..');
                pathToModule = [module, ...pathToModule];
            } while (!(0, utils_1.hasGradleModule)(cwd, childModuleName));
            additionalArgs = `-p ${pathToModule.join('/')} `;
        }
        return { cwd, command: `${additionalArgs}${this.commandAliases[alias]}` };
    }
}
exports.GradleBuilder = GradleBuilder;
//# sourceMappingURL=gradle-builder.class.js.map