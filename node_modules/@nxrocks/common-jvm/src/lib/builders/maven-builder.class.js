"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MavenBuilder = void 0;
const constants_1 = require("../constants");
const builder_core_interface_1 = require("./builder-core.interface");
const path_1 = require("path");
const maven_utils_1 = require("../utils/maven-utils");
class MavenBuilder {
    constructor(commandAliases) {
        this.commandAliases = commandAliases;
    }
    getBuildSystemType() {
        return builder_core_interface_1.BuildSystem.MAVEN;
    }
    getExecutable(ignoreWrapper, useLegacyWrapper = false) {
        if (ignoreWrapper)
            return constants_1.MAVEN_EXECUTABLE;
        else
            return useLegacyWrapper ? constants_1.MAVEN_WRAPPER_EXECUTABLE_LEGACY : constants_1.MAVEN_WRAPPER_EXECUTABLE;
    }
    getCommand(alias, options) {
        let additionalArgs = '';
        let cwd = options.cwd;
        if (!options.ignoreWrapper && !(0, maven_utils_1.hasMavenWrapper)(options.cwd) && !options.runFromParentModule) {
            throw new Error(`⚠️ You chose not to use the Maven wrapper from the parent module, but no wrapper was found in current child module`);
        }
        if (options.runFromParentModule) {
            let pathToModule = [];
            const childModuleName = (0, path_1.basename)(cwd);
            do {
                const module = (0, path_1.basename)(cwd);
                cwd = (0, path_1.resolve)(cwd, '..');
                pathToModule = [module, ...pathToModule];
            } while (!(0, maven_utils_1.hasMavenModule)(cwd, childModuleName));
            additionalArgs = `-f ${pathToModule.join('/')} `;
        }
        return { cwd, command: `${additionalArgs}${this.commandAliases[alias]}` };
    }
}
exports.MavenBuilder = MavenBuilder;
//# sourceMappingURL=maven-builder.class.js.map