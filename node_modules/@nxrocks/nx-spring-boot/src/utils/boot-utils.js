"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchBootDependencies = exports.isBootProject = exports.buildBootDownloadUrl = exports.runBootPluginCommand = exports.DEFAULT_SPRING_INITIALIZR_URL = void 0;
const tslib_1 = require("tslib");
const querystring_1 = require("querystring");
const index_1 = require("../index");
const common_jvm_1 = require("@nxrocks/common-jvm");
const constants_1 = require("../core/constants");
const node_fetch_1 = require("node-fetch");
const getBuilder = (cwd) => {
    if ((0, common_jvm_1.hasMavenProject)(cwd))
        return constants_1.MAVEN_BUILDER;
    if ((0, common_jvm_1.hasGradleProject)(cwd))
        return constants_1.GRADLE_BUILDER;
    throw new Error(`Cannot determine the build system. No 'pom.xml' nor 'build.gradle' file found under '${cwd}'`);
};
exports.DEFAULT_SPRING_INITIALIZR_URL = 'https://start.spring.io';
function runBootPluginCommand(commandAlias, params, options = { cwd: process.cwd(), ignoreWrapper: false, runFromParentModule: false }) {
    return (0, common_jvm_1.runBuilderCommand)(commandAlias, getBuilder, params, options);
}
exports.runBootPluginCommand = runBootPluginCommand;
function buildBootDownloadUrl(options) {
    const params = [
        { key: 'type', value: options.buildSystem },
        { key: 'language', value: options.language },
        { key: 'name', value: options.name },
        { key: 'groupId', value: options.groupId },
        { key: 'artifactId', value: options.artifactId },
        { key: 'version', value: options.version },
        { key: 'packageName', value: options.packageName },
        { key: 'javaVersion', value: options.javaVersion },
        { key: 'packaging', value: options.packaging },
        { key: 'dependencies', value: options.projectDependencies.join(',') },
        {
            key: 'description',
            value: options.description ? (0, querystring_1.escape)(options.description) : null,
        },
        { key: 'bootVersion', value: options.bootVersion },
    ].filter((e) => !!e.value);
    const queryParams = params.map((e) => `${e.key}=${e.value}`).join('&');
    return `${options.springInitializerUrl}/starter.zip?${queryParams}`;
}
exports.buildBootDownloadUrl = buildBootDownloadUrl;
function isBootProject(project) {
    if ((0, common_jvm_1.hasMultiModuleMavenProject)(project.root) || (0, common_jvm_1.hasMultiModuleGradleProject)(project.root))
        return true;
    if ((0, common_jvm_1.isMavenProject)(project)) {
        return (0, common_jvm_1.checkProjectBuildFileContains)(project, {
            fragments: ['<artifactId>spring-boot-starter-parent</artifactId>'],
        });
    }
    if ((0, common_jvm_1.isGradleProject)(project)) {
        return (0, common_jvm_1.checkProjectBuildFileContains)(project, {
            fragments: [
                "id 'io.spring.dependency-management'",
                'id("io.spring.dependency-management"'
            ],
        });
    }
    return false;
}
exports.isBootProject = isBootProject;
function fetchBootDependencies(options) {
    var _a, _b;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const response = yield (0, node_fetch_1.default)(`${options.springInitializerUrl}/dependencies`, (0, common_jvm_1.getCommonHttpHeaders)(index_1.NX_SPRING_BOOT_PKG, options.springInitializerUrl, options.proxyUrl));
        return (_b = (_a = (yield response.json())) === null || _a === void 0 ? void 0 : _a.dependencies) !== null && _b !== void 0 ? _b : {};
    });
}
exports.fetchBootDependencies = fetchBootDependencies;
//# sourceMappingURL=boot-utils.js.map